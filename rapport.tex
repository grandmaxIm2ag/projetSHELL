\documentclass{report}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{mathrsfs}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{siunitx}
\lstset{
  basicstyle=\footnotesize\tt,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  language=C,                 % the language of the code
  keywordstyle=\bf,
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  tabsize=2                       % sets default tabsize to 2 spaces
}





\author{Grand Maxence, Muller Lucie}
\title{Syst\`emes et R\'eseaux  : R\'ealisations d'un mini shell}
\date{17/02/2017}


\begin{document}
	
	\maketitle
	\tableofcontents

	\chapter*{Introduction}
		Durant le projet, nous avons cr\'e\'e un interpr\^eteur de commande shell mais d'une fa\c{c}on simplifi\'ee. Il a fallut en comprendre la structure pour la refaire, et permettre a notre programme d'acc\`eder \`a des commandes simples puis \`a des commandes plus complexes g\`erant les redirections d'entr\'ees-sorties ainsi que les s\'equences de commandes pip\'ees.\\
		Dans un second temps, nous avons am\'elior\'e notre shell pour lui permettant la gestion des diff\'erents plans, des signaux de terminaison et de suspension, des zombis et des jobs.
	\chapter{Partie 1}
		\section{Commandes simples}
		Dans cette partie nous devions impl\'ement\'e une fonction permettant d'ex\'ecuter une commande simple en shell. Pour tester no\^otre fonction nous avons tester plusieurs commande n'utilisant ni les pipes ni les redirections dans un shell et dans n\^otre programme shell. \\
		Code :
		\begin{lstlisting}
void commande_simple(struct cmdline *l){
	int pid = Fork();
	int status;
	if(pid == 0){
		execvp(l->seq[0][0], l->seq[0]);
		exit(0);
	}
	else{
		waitpid(pid, &status, 0);
	}
}
		\end{lstlisting} 
		Test \\ SHELL
		\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ ls
csapp.c  Makefile     rapport.log  rapport.tex  readcmd.c  README.md  shell.c    test   test3  tst    tube_simple.c
csapp.h  rapport.aux  rapport.pdf  rapport.toc  readcmd.h  shell      sujet.pdf  test2  text   tst.c  waitpid1.c
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ ls -l
total 2688
-rwx------ 1 maxence maxence  20259 déc.  25  2014 csapp.c
-rwx------ 1 maxence maxence   6105 mars  16  2014 csapp.h
-rwx------ 1 maxence maxence    136 oct.   6  2009 Makefile
-rwx------ 1 maxence maxence   1499 févr.  8 15:58 rapport.aux
-rwx------ 1 maxence maxence  30949 févr.  8 15:58 rapport.log
-rwx------ 1 maxence maxence 128494 févr.  8 15:58 rapport.pdf
-rwx------ 1 maxence maxence   2558 févr.  8 16:02 rapport.tex
-rwx------ 1 maxence maxence    933 févr.  8 15:58 rapport.toc
-rwx------ 1 maxence maxence   4699 févr.  8 14:07 readcmd.c
-rwx------ 1 maxence maxence   1029 févr.  8 14:02 readcmd.h
-rwx------ 1 maxence maxence     14 févr.  7 18:02 README.md
-rwx------ 1 maxence maxence  41024 févr.  8 15:45 shell
-rwx------ 1 maxence maxence   4338 févr.  8 16:03 shell.c
-rwx------ 1 maxence maxence  94332 févr.  7 12:01 sujet.pdf
-rwx------ 1 maxence maxence    150 févr.  8 13:57 test
-rwx------ 1 maxence maxence      3 févr.  8 13:58 test2
-rwx------ 1 maxence maxence      3 févr.  7 15:51 test3
-rwx------ 1 maxence maxence      0 févr.  7 15:36 text
-rwx------ 1 maxence maxence  18008 févr.  8 12:08 tst
-rwx------ 1 maxence maxence    723 févr.  7 13:55 tst.c
-rwx------ 1 maxence maxence    815 janv. 31 15:18 tube_simple.c
-rwx------ 1 maxence maxence    657 janv. 20  2009 waitpid1.c
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ cat test
19
pp.c
csapp.h
Makefile
readcmd.c
readcmd.h
README.md
shell
shell.c
shell.o
sujet.pdf
test
test2
test3
text
tst
tst.c
tst.o
tube_simple.c
waitpid1.c
		\end{lstlisting}
		shell.c
		\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
shell> ls
csapp.c  Makefile     rapport.log  rapport.tex	readcmd.c  README.md  shell.c	 test	test3  tst    tube_simple.c
csapp.h  rapport.aux  rapport.pdf  rapport.toc	readcmd.h  shell      sujet.pdf  test2	text   tst.c  waitpid1.c
shell> ls -l
total 2688
-rwx------ 1 maxence maxence  20259 déc.  25  2014 csapp.c
-rwx------ 1 maxence maxence   6105 mars  16  2014 csapp.h
-rwx------ 1 maxence maxence    136 oct.   6  2009 Makefile
-rwx------ 1 maxence maxence   1499 févr.  8 15:58 rapport.aux
-rwx------ 1 maxence maxence  30949 févr.  8 15:58 rapport.log
-rwx------ 1 maxence maxence 128494 févr.  8 15:58 rapport.pdf
-rwx------ 1 maxence maxence   4558 févr.  8 16:05 rapport.tex
-rwx------ 1 maxence maxence    933 févr.  8 15:58 rapport.toc
-rwx------ 1 maxence maxence   4699 févr.  8 14:07 readcmd.c
-rwx------ 1 maxence maxence   1029 févr.  8 14:02 readcmd.h
-rwx------ 1 maxence maxence     14 févr.  7 18:02 README.md
-rwx------ 1 maxence maxence  41024 févr.  8 16:06 shell
-rwx------ 1 maxence maxence   4338 févr.  8 16:03 shell.c
-rwx------ 1 maxence maxence  94332 févr.  7 12:01 sujet.pdf
-rwx------ 1 maxence maxence    150 févr.  8 13:57 test
-rwx------ 1 maxence maxence      3 févr.  8 13:58 test2
-rwx------ 1 maxence maxence      3 févr.  7 15:51 test3
-rwx------ 1 maxence maxence      0 févr.  7 15:36 text
-rwx------ 1 maxence maxence  18008 févr.  8 12:08 tst
-rwx------ 1 maxence maxence    723 févr.  7 13:55 tst.c
-rwx------ 1 maxence maxence    815 janv. 31 15:18 tube_simple.c
-rwx------ 1 maxence maxence    657 janv. 20  2009 waitpid1.c
shell> cat test
19
pp.c
csapp.h
Makefile
readcmd.c
readcmd.h
README.md
shell
shell.c
shell.o
sujet.pdf
test
test2
test3
text
tst
tst.c
tst.o
tube_simple.c
waitpid1.c
shell>  echo "test"
"test"
shell>
		\end{lstlisting}
		\section{Commande avec redirections d'entr\'ee ou de sortie}
			Dans cette section nous devions implenter une fonction permettant de ger\'les redirections d'entr\'ee ou de sortie. Nos test ont suivi les m\^eme principes que l'\'etape pr\'ec\'edente \`a l'exception que seul les commandes avec pipes ne seront pas test\'ees ici. \\ Code :
			\begin{lstlisting}
void commande_redirection(struct cmdline *l){
	int fOut = 1; int fIn = 0;

	if(l->in != NULL)
		fIn = open(l->in, O_RDONLY,0);
	if(l->out != NULL)
		fOut = open(l->out, O_WRONLY | O_CREAT, 0700) ;

	int pid = Fork(); int status;
	if(pid == 0){
		if(fOut != 1){
			close(1);
			dup2(fOut, 1);
		}
		if(fIn == 0){
			execvp(l->seq[0][0], l->seq[0]);
			exit(0);
		}else{
			close(0);
			dup2(fIn, 0);
			execvp(l->seq[0][0], l->seq[0]);
			exit(0);
		}
		
	}
	else{
		waitpid(pid, &status, 0);
	}
}
			\end{lstlisting}
			Test \\ SHELL
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ ls -l > test
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ cat test
total 2688
-rwx------ 1 maxence maxence  20259 déc.  25  2014 csapp.c
-rwx------ 1 maxence maxence   6105 mars  16  2014 csapp.h
-rwx------ 1 maxence maxence    136 oct.   6  2009 Makefile
-rwx------ 1 maxence maxence   1499 févr.  8 16:10 rapport.aux
-rwx------ 1 maxence maxence  31866 févr.  8 16:10 rapport.log
-rwx------ 1 maxence maxence 218712 févr.  8 16:10 rapport.pdf
-rwx------ 1 maxence maxence   7408 févr.  8 16:16 rapport.tex
-rwx------ 1 maxence maxence    933 févr.  8 16:10 rapport.toc
-rwx------ 1 maxence maxence   4699 févr.  8 14:07 readcmd.c
-rwx------ 1 maxence maxence   1029 févr.  8 14:02 readcmd.h
-rwx------ 1 maxence maxence     14 févr.  7 18:02 README.md
-rwx------ 1 maxence maxence  41024 févr.  8 16:06 shell
-rwx------ 1 maxence maxence   4338 févr.  8 16:03 shell.c
-rwx------ 1 maxence maxence  94332 févr.  7 12:01 sujet.pdf
-rwx------ 1 maxence maxence      0 févr.  8 16:16 test
-rwx------ 1 maxence maxence      3 févr.  8 13:58 test2
-rwx------ 1 maxence maxence      3 févr.  7 15:51 test3
-rwx------ 1 maxence maxence      0 févr.  7 15:36 text
-rwx------ 1 maxence maxence  18008 févr.  8 12:08 tst
-rwx------ 1 maxence maxence    723 févr.  7 13:55 tst.c
-rwx------ 1 maxence maxence    815 janv. 31 15:18 tube_simple.c
-rwx------ 1 maxence maxence    657 janv. 20  2009 waitpid1.c
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ wc -l < test
23
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ wc -c < test
1347
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ wc - < test > test2
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ cat test2
  23  200 1347 -
			\end{lstlisting}
		shell.c
		\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
shell> ls -l > test
shell> cat test
total 2816
-rwx------ 1 maxence maxence  20259 déc.  25  2014 csapp.c
-rwx------ 1 maxence maxence   6105 mars  16  2014 csapp.h
-rwx------ 1 maxence maxence    136 oct.   6  2009 Makefile
-rwx------ 1 maxence maxence   1499 févr.  8 16:10 rapport.aux
-rwx------ 1 maxence maxence  31866 févr.  8 16:10 rapport.log
-rwx------ 1 maxence maxence 218712 févr.  8 16:10 rapport.pdf
-rwx------ 1 maxence maxence   9314 févr.  8 16:22 rapport.tex
-rwx------ 1 maxence maxence    933 févr.  8 16:10 rapport.toc
-rwx------ 1 maxence maxence   4699 févr.  8 14:07 readcmd.c
-rwx------ 1 maxence maxence   1029 févr.  8 14:02 readcmd.h
-rwx------ 1 maxence maxence     14 févr.  7 18:02 README.md
-rwx------ 1 maxence maxence  41024 févr.  8 16:23 shell
-rwx------ 1 maxence maxence   4343 févr.  8 16:23 shell.c
-rwx------ 1 maxence maxence  94332 févr.  7 12:01 sujet.pdf
-rwx------ 1 maxence maxence      1 févr.  8 16:17 test
-rwx------ 1 maxence maxence      1 févr.  8 16:17 test2
-rwx------ 1 maxence maxence      3 févr.  7 15:51 test3
-rwx------ 1 maxence maxence      0 févr.  7 15:36 text
-rwx------ 1 maxence maxence  18008 févr.  8 12:08 tst
-rwx------ 1 maxence maxence    723 févr.  7 13:55 tst.c
-rwx------ 1 maxence maxence    815 janv. 31 15:18 tube_simple.c
-rwx------ 1 maxence maxence    657 janv. 20  2009 waitpid1.c
shell> wc -l < test
23
shell> wc -c < test
1347
shell> wc - < test > test2
shell> cat test2
  23  200 1347 -
		\end{lstlisting}
		\section{S\'equence de commandes compos\'ee de deux commandes reli\'es par un tube}
			Dans cette section, nous devons impl\'ementer une fonction permettant de g\`erer les pipes, c'est-\`a-dire de faire en sorte de rediriger la sortie standard d'un processus ou d'une commande vers l'entr\'ee standard d'un autre processus. Dans un premier temps, nous avons travaill\'e avec un seul pipe entre deux commandes. \\Code :\\
			\begin{lstlisting}
void commande_pipe(struct cmdline *l){
	int tailleSeq; int tmp;
	for(tailleSeq=0; l->seq[tailleSeq+1]!=0; tailleSeq++);
	int pid = Fork(); int status; int i=0; int desc[2];
	if(pid == 0){
		pipe(desc);
		pid=Fork();
		if(pid != 0){
			dup2(desc[0], 0);
			close(desc[1]);
			while( (tmp = waitpid(pid, &status, WNOHANG|WUNTRACED)) != pid);
			execvp(l->seq[1][0], l->seq[tailleSeq]);
			close(desc[0]);
			exit(0);
		}else{
			for(i = 1; i<=tailleSeq; i++){
				if(i+1 <= tailleSeq){
					dup2(desc[1], 1);
					close(desc[0]);
					pipe(desc);
					pid = Fork();
					if(pid != 0){
						dup2(desc[0], 0);
						close(desc[1]);
						waitpid(pid, &status, 0);
						execvp(l->seq[tailleSeq - i][0], l->seq[tailleSeq-1]);
						exit(0);
					}
				} else{
					dup2(desc[1], 1);
					close(desc[0]);
					execvp(l->seq[0][0], l->seq[0]);
					exit(0);
				}
			}		
		}
	}else{
		waitpid(pid, &status, 0);
	}
}
			\end{lstlisting}
			test \\ SHELL
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
shell> ls -l | wc -l
23
shell> ls -l | wc -l | wc -c
3
			\end{lstlisting}
			shell.c
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ ls -l | wc -l
23
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ ls -l | wc -l | wc -c
3
			\end{lstlisting}
		\section{S\'equence de commandes compos\'ee de plusieurs commandes et plusieurs tubes}
	Cette partie est une am\`elioration apport\'ee a la partie pr\'ec\'edente. En effet, nous avons impl\'ement\'e une fonction qui permet au shell de g\`erer plusieurs pipes entre plusieurs commandes. Les diff\`erents processus appel\'es ne fonctionnent pas les uns apr\`s les autres, mais d'une fa\c{c}on pseudo-parall\`ele : le processus ne fonctionne que lorsqu'il re\c{c}oit les donn\`ees du processus qui le pr\'ec\`ede, qui envoie ces donn\'es au fur et a mesure\\Code :
			\begin{lstlisting}
void commande1_final(struct cmdline *l){
	if(l->seq[1]!=0){

		int fOut = 1; int fIn = 0;
			if(l->in != NULL)
			fIn = open(l->in, O_RDONLY,0);
		if(l->out != NULL)
			fOut = open(l->out, O_WRONLY | O_CREAT, 0700) ;

		int tailleSeq; int tmp;
		for(tailleSeq=0; l->seq[tailleSeq+1]!=0; tailleSeq++);

		int pid = Fork(); int status; int i=0; int desc[2];
		if(pid == 0){
			pipe(desc);
			pid=Fork();
			if(pid != 0){
				dup2(fOut, 1);
				dup2(desc[0], 0);
				close(desc[1]);
				while( (tmp = waitpid(pid, &status, WNOHANG|WUNTRACED)) != pid);
				execvp(l->seq[1][0], l->seq[tailleSeq]);
				close(desc[0]);
				exit(0);
			}else{
				for(i = 1; i<=tailleSeq; i++){
					if(i+1 <= tailleSeq){
						dup2(desc[1], 1);
						close(desc[0]);
						pipe(desc);
						pid = Fork();
						if(pid != 0){
							dup2(desc[0], 0);
							close(desc[1]);
							waitpid(pid, &status, 0);
							execvp(l->seq[tailleSeq - i][0], l->seq[tailleSeq-1]);
							exit(0);
						}
					} else{
						dup2(fIn, 0);
						dup2(desc[1], 1);
						close(desc[0]);
						execvp(l->seq[0][0], l->seq[0]);
						close(desc[1]);
						exit(0);
					}
				}		
			}
		}else{
			waitpid(pid, &status, 0);
		}
	}else{
		commande_redirection(l);
	}
}
			\end{lstlisting}
			test \\ SHELL
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ head -5 < test | tail -2 | sort > tmp2
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ cat tmp2
-rwx------ 1 maxence maxence    136 oct.   6  2009 Makefile
-rwx------ 1 maxence maxence   1499 févr.  8 16:10 rapport.aux
			\end{lstlisting}
			shell.c
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
shell>  head -5 < test | tail -2 | sort > tmp
shell> cat tmp
-rwx------ 1 maxence maxence    136 oct.   6  2009 Makefile
-rwx------ 1 maxence maxence   1499 févr.  8 16:10 rapport.aux
			\end{lstlisting}
	\chapter{Partie Bonus}
		\section{Ex\'ecution de commandes en arri\`ere plan}
	Dans cette section, nous avons impl\'ement\'e une fonction permettant de faire fonctionner des processus en arri\`ere plan : ils continuent de fonctionner sans bloquer le shell, ce qui permet a l'utilisateur de continuer de travailler et taper d'autres commandes pendant que le processus continue.\\Code :
			\begin{lstlisting}
void commande_bg(struct cmdline *l){
	int pid, status;

	pid = Fork();

	if(pid == 0){
		execvp(l->seq[0][0], l->seq[0]);
		exit(0);
	}else{
		if(l->bg);
		else{
			waitpid(pid, &status, 0);
		}
	}
}
			\end{lstlisting}
			test \\ SHELL
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
			\end{lstlisting}
			shell.c
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
			\end{lstlisting}
		\section{Changer l'\'etat du processus au premier plan}
	Dans cette section, on a modifi\'e notre interpr\^eteur afin qu'il reconnaisse certains signaux agissant sur les processus en premier plan qui sont les signaux de terminaison et de suspension respectivement envoy\'es par la pression des touches Ctrl-C et Ctrl-Z.\\Code :
			\begin{lstlisting}
void stop(int sig){
	printf("Fini\n");
	kill(child, SIGKILL);
}
void suspend(int sig){
	printf("Suspendu\n");
	kill(child, SIGSTOP);
}
void commande_signaux(struct cmdline *l){

	int pid = Fork(); int status;

	Signal(SIGINT, stop);	
	Signal(SIGTSTP, suspend);

	if(pid == 0){
		execvp(l->seq[0][0], l->seq[0]);
		exit(0);
	}else{
		child = pid;
		Signal(SIGINT, stop);
		Signal(SIGTSTP, suspend);
		while (waitpid(pid, &status, 0) != pid);
	}
}
			\end{lstlisting}
			test \\ SHELL 
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ gedit 
^C
[2]+  Fini                    okular
maxence@Sybil:/media/maxence/MyLinuxLive1/cours/l3_info/s06/SR/projetSHELL$ gedit 
^Z
[1]+  Arrêté                gedit

			\end{lstlisting}
			shell.c 
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
shell> gedit
^CFini

			\end{lstlisting}
		\section{Gestion des zombis}
	Dans cette section nous devons g\`erer les cas de prosessus fils qui n'ont pas termin\'es lors de la terminaison du shell, appel\'es zombis. Pour cela nous avons ajout\'e un signal qui le fait attendre jusqu'\`a la terminaison de chacun de ces fils, avant de se terminer lui-m\^eme.\\Code :\\
			\begin{lstlisting}
void zombi(int sig)
{
    pid_t pid;

    if ((pid = waitpid(-1, NULL, WNOHANG|WUNTRACED)) < 0)
        unix_error("waitpid error");
    printf("Handler reaped child %d\n", (int)pid);
    return;
}

void commande_zombi(struct cmdline *l){
	Signal( SIGCHLD, zombi);
	int pid = Fork();
	int status;
	if(pid == 0){
		execvp(l->seq[0][0], l->seq[0]);
		exit(0);
	}
}
			\end{lstlisting}
			test \\ SHELL 
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
			\end{lstlisting}
			shell.c 
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
			\end{lstlisting}
		\section{Commande integr\'ee jobs}
			Dans cette section, nous avons impl\'ementer la fonction Jobs du shell permettant d'afficher sur la sortie standard les differents job d\'emarr\'es durant la session courante de ce shell. Quand jobs indique la terminaison d'un job, il l'efface de la liste et donc ce job n'est plus dans la liste \`a l'appel suivant de jobs.\\Code :
			\begin{lstlisting}
			\end{lstlisting}
			test \\ SHELL 
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
			\end{lstlisting}
			shell.c 
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
			\end{lstlisting}
		\section{Agir sur les commandes en arri\`ere plan}
			Dans cette section, il fallait que le programme agisse sur les jobs en arri\'ere plan. Pour cela il y avait trois commandes a impl\'ementer qui sont fg pour ramener un jobs au premier plan, bg pour mettre un jobs en arri\`ere plan et stop pour arr\^eter le jobs.\\Code : 
			\begin{lstlisting}
			\end{lstlisting}
			test \\ SHELL
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
			\end{lstlisting}
			shell.c 
			\begin{lstlisting}[frame=single,basicstyle=\footnotesize,language=bash]
			\end{lstlisting}
\end{document}
